<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Musical 3D Art Studio</title>  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>  
    <style>  
        body {  
            margin: 0;  
            padding: 0;  
            font-family: Arial, sans-serif;  
            background: linear-gradient(135deg, #000000 0%, #ff0000 100%);  
            color: rgb(0, 255, 255);  
            overflow: hidden;  
        }  
          
        .container {  
            position: relative;  
            width: 100vw;  
            height: 100vh;  
        }  
          
        .canvas-container {  
            position: relative;  
            width: 100%;  
            height: 100%;  
        }  
          
        #mandalaCanvas {  
            position: absolute;  
            top: 0;  
            left: 0;  
            z-index: 2;  
            pointer-events: auto;  
        }  
          
        #threeCanvas {  
            position: absolute;  
            top: 0;  
            left: 0;  
            z-index: 1;  
        }  
          
        .controls {
            position: absolute;
            top: 60px;
            right: 20px;
            background: linear-gradient(135deg, #5606884d, #2e2d2e50);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px 10px 13px rgb(255, 0, 217));
            border: 3px solid rgba(255, 89, 0, 0.479);
            max-height: 50vh;
            overflow-y: auto;
            width: 280px;
            z-index: 1000;
            transition: transform 0.9s ease, opacity 0.3s ease;
        }

        .controls.hidden {
            transform: translateX(300px);
            opacity: 0;
            pointer-events: none;
        }
          
        .control-group {  
            margin-bottom: 20px;  
            padding: 15px;  
            background: rgba(255, 255, 255, 0.1);  
            border-radius: 8px;  
        }  
          
        .control-group h3 {  
            margin: 0 0 10px 0;  
            color: #fff;  
            font-size: 16px;  
        }  
          
        label {  
            display: block;  
            margin: 10px 0 5px 0;  
            font-size: 12px;  
        }  
          
        input[type="range"] {  
            width: 100%;  
            margin-bottom: 5px;  
        }  
          
        input[type="color"] {  
            width: 100%;  
            height: 30px;  
            border: none;  
            border-radius: 5px;  
            cursor: pointer;  
        }  
          
        button {  
            width: 100%;  
            padding: 8px;  
            margin: 3px 0;  
            border: none;  
            border-radius: 5px;  
            background: rgba(255, 255, 255, 0.2);  
            color: white;  
            cursor: pointer;  
            font-size: 12px;  
            transition: background 0.3s;  
        }  
          
        button:hover {  
            background: rgba(255, 255, 255, 0.3);  
        }  
          
        button.active {  
            background: rgba(255, 255, 255, 0.4);  
        }  
          
        .mode-buttons {  
            display: grid;  
            grid-template-columns: 1fr 1fr;  
            gap: 5px;  
            margin: 10px 0;  
        }  
          
        #startButton {  
            position: absolute;  
            top: 50%;  
            left: 50%;  
            transform: translate(-50%, -50%);  
            padding: 20px 40px;  
            font-size: 18px;  
            background: rgba(0, 0, 0, 0.8);  
            border: 2px solid #4CAF50;  
            color: white;  
            border-radius: 10px;  
            cursor: pointer;  
            z-index: 100;  
            backdrop-filter: blur(10px);  
        }  
          
        #startButton:hover {  
            background: rgba(0, 0, 0, 0.9);  
        }  
          
        .audio-info {  
            position: absolute;  
            bottom: 20px;  
            left: 20px;  
            background: rgba(0, 0, 0, 0.8);  
            padding: 15px;  
            border-radius: 10px;  
            font-size: 13px;  
            z-index: 10;  
            display: none;  
        }  
          
        .hidden {  
            display: none;  
        }  
    </style>  
</head>  
<body>  
    <div class="container">  
        <button id="startButton">START MUSICAL ART EXPERIENCE</button>  
          
        <div class="canvas-container">  
            <canvas id="mandalaCanvas"></canvas>  
            <div id="threeCanvas"></div>  
        </div>  
          
        <div class="audio-info" id="audioInfo">  
            <div>Musical Drawing Active</div>  
            <div>Move for different notes</div>  
            <div>Last Note: <span id="lastNote">-</span></div>  
        </div>  
          
        <div class="controls">  
            <div class="control-group">  
                <h3>Mode</h3>  
                <div class="mode-buttons">  
                    <button id="mandalaMode" class="active">Mandala</button>  
                    <button id="particleMode">Particles</button>  
                </div>  
                <button id="combinedMode">Combined Mode</button>  
            </div>  
              
            <div class="control-group" id="mandalaControls">  
                <h3>Mandala Drawing</h3>  
                <input type="color" id="mandalaColor" value="#ff0066">  
                  
                <label>Brush Size: <span id="brushSizeValue">5</span>px</label>  
                <input type="range" id="brushSize" min="1" max="30" value="5">  
                  
                <label>Symmetry Points: <span id="symmetryValue">8</span></label>  
                <input type="range" id="symmetryPoints" min="2" max="32" value="8">  
                  
                <label>  
                    <input type="checkbox" id="symmetryToggle" checked> Enable Symmetry  
                </label>  
            </div>  
              
            <div class="control-group" id="particleControls" style="display: none;">  
                <h3>Particle Effects</h3>  
                <input type="color" id="particleStartColor" value="#ff0000">  
                <input type="color" id="particleEndColor" value="#00ff00">  
                  
                <label>Particle Size: <span id="particleSizeValue">3</span></label>  
                <input type="range" id="particleSize" min="0.5" max="10" value="3" step="0.5">  
                  
                <label>Gravity: <span id="gravityValue">-0.5</span></label>  
                <input type="range" id="gravity" min="-2" max="2" value="-0.5" step="0.1">  
                  
                <label>Wind: <span id="windValue">1</span></label>  
                <input type="range" id="windForce" min="0" max="3" value="1" step="0.1">  
                  
                <label>Emission Rate: <span id="emissionValue">50</span></label>  
                <input type="range" id="emissionRate" min="10" max="200" value="50">  
            </div>  
              
            <div class="control-group">  
                <h3>Actions</h3>  
                <button id="clearAll">Clear All</button>  
                <button id="clearMandala">Clear Mandala Only</button>  
                <button id="clearParticles">Clear Particles Only</button>  
            </div>  
              
            <div class="control-group">  
                <h3>Export Your Art</h3>  
                <button id="previewExport">Preview</button>  
                <button id="freeDownload">Save Image</button>  
            </div>  
        </div>  
    </div>

    <script>  
        let scene, camera, renderer, particleSystem;  
        let mandalaCanvas, mandalaCtx;  
        let currentMode = 'mandala';  
        let isDrawing = false;  
        let lastX = 0, lastY = 0;  
        let audioEnabled = false;  
        let synth;  
          
        // Audio timing for continuous sound  
        let audioLastTrigger = 0;  
        let lastAudioX = 0;  
        let lastAudioY = 0;  
          
        let mandalaColor = '#ff0066';  
        let brushSize = 5;  
        let symmetryPoints = 8;  
        let symmetryEnabled = true;  
          
        let particleParams = {  
            startColor: new THREE.Color('#000000'),  
            endColor: new THREE.Color('#ff0066'),  
            size: 3,  
            gravity: -0.5,  
            wind: 1,  
            emissionRate: 50,  
            particles: []  
        };  
          
        function init() {  
            setupCanvases();  
            setupThreeJS();  
            setupEventListeners();  
            setupAudio();  
            setMode('mandala');  
        }  
          
        function setupCanvases() {  
            mandalaCanvas = document.getElementById('mandalaCanvas');  
            mandalaCtx = mandalaCanvas.getContext('2d');  
            mandalaCanvas.width = window.innerWidth;  
            mandalaCanvas.height = window.innerHeight;  
            mandalaCanvas.style.background = 'transparent';  
        }  
          
        function setupThreeJS() {  
            scene = new THREE.Scene();  
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);  
            camera.position.z = 10;  
              
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });  
            renderer.setSize(window.innerWidth, window.innerHeight);  
            renderer.setClearColor(0x000000, 0);  
              
            document.getElementById('threeCanvas').appendChild(renderer.domElement);  
            createParticleSystem();  
            animate();  
        }  
          
        function createParticleSystem() {  
            const geometry = new THREE.BufferGeometry();  
            const positions = new Float32Array(1000 * 3);  
            const colors = new Float32Array(1000 * 3);  
            const sizes = new Float32Array(1000);  
              
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));  
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));  
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));  
              
            const material = new THREE.ShaderMaterial({  
                uniforms: {  
                    pointTexture: { value: createParticleTexture() }  
                },  
                vertexShader: `  
                    attribute float size;  
                    varying vec3 vColor;  
                    void main() {  
                        vColor = color;  
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);  
                        gl_PointSize = size * (300.0 / -mvPosition.z);  
                        gl_Position = projectionMatrix * mvPosition;  
                    }  
                `,  
                fragmentShader: `  
                    uniform sampler2D pointTexture;  
                    varying vec3 vColor;  
                    void main() {  
                        gl_FragColor = vec4(vColor, 1.0);  
                        gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);  
                    }  
                `,  
                blending: THREE.AdditiveBlending,  
                depthTest: false,  
                transparent: true,  
                vertexColors: true  
            });  
              
            particleSystem = new THREE.Points(geometry, material);  
            scene.add(particleSystem);  
        }  
          
        function createParticleTexture() {  
            const canvas = document.createElement('canvas');  
            canvas.width = 32;  
            canvas.height = 32;  
            const context = canvas.getContext('2d');  
              
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);  
            gradient.addColorStop(0, 'rgba(255,255,255,1)');  
            gradient.addColorStop(1, 'rgba(255,255,255,0)');  
              
            context.fillStyle = gradient;  
            context.fillRect(0, 0, 32, 32);  
              
            return new THREE.CanvasTexture(canvas);  
        }  
          
        function setupAudio() {  
            document.getElementById('startButton').addEventListener('click', async () => {  
                try {  
                    await Tone.start();  
                    audioEnabled = true;  
                      
                    synth = new Tone.PolySynth(Tone.Synth, {  
                        oscillator: { type: "sine" },  
                        envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.5 }  
                    }).toDestination();  
                      
                    document.getElementById('startButton').style.display = 'none';  
                    document.getElementById('audioInfo').style.display = 'block';  
                } catch (error) {  
                    console.log('Audio setup failed');  
                    document.getElementById('startButton').style.display = 'none';  
                }  
            });  
        }  
          
        function setupEventListeners() {  
            document.getElementById('mandalaMode').addEventListener('click', () => setMode('mandala'));  
            document.getElementById('particleMode').addEventListener('click', () => setMode('particle'));  
            document.getElementById('combinedMode').addEventListener('click', () => setMode('combined'));  
              
            mandalaCanvas.addEventListener('mousedown', startDrawing);  
            mandalaCanvas.addEventListener('mousemove', draw);  
            mandalaCanvas.addEventListener('mouseup', stopDrawing);  
            mandalaCanvas.addEventListener('mouseout', stopDrawing);  
              
            mandalaCanvas.addEventListener('touchstart', handleTouch, { passive: false });  
            mandalaCanvas.addEventListener('touchmove', handleTouch, { passive: false });  
            mandalaCanvas.addEventListener('touchend', stopDrawing);  
              
            document.getElementById('mandalaColor').addEventListener('input', (e) => {  
                mandalaColor = e.target.value;  
            });  
              
            document.getElementById('brushSize').addEventListener('input', (e) => {  
                brushSize = parseInt(e.target.value);  
                document.getElementById('brushSizeValue').textContent = brushSize;  
            });  
              
            document.getElementById('symmetryPoints').addEventListener('input', (e) => {  
                symmetryPoints = parseInt(e.target.value);  
                document.getElementById('symmetryValue').textContent = symmetryPoints;  
            });  
              
            document.getElementById('symmetryToggle').addEventListener('change', (e) => {  
                symmetryEnabled = e.target.checked;  
            });  
              
            document.getElementById('particleStartColor').addEventListener('input', (e) => {  
                particleParams.startColor = new THREE.Color(e.target.value);  
            });  
              
            document.getElementById('particleEndColor').addEventListener('input', (e) => {  
                particleParams.endColor = new THREE.Color(e.target.value);  
            });  
              
            document.getElementById('particleSize').addEventListener('input', (e) => {  
                particleParams.size = parseFloat(e.target.value);  
                document.getElementById('particleSizeValue').textContent = particleParams.size;  
            });  
              
            document.getElementById('gravity').addEventListener('input', (e) => {  
                particleParams.gravity = parseFloat(e.target.value);  
                document.getElementById('gravityValue').textContent = particleParams.gravity;  
            });  
              
            document.getElementById('windForce').addEventListener('input', (e) => {  
                particleParams.wind = parseFloat(e.target.value);  
                document.getElementById('windValue').textContent = particleParams.wind;  
            });  
              
            document.getElementById('emissionRate').addEventListener('input', (e) => {  
                particleParams.emissionRate = parseInt(e.target.value);  
                document.getElementById('emissionValue').textContent = particleParams.emissionRate;  
            });  
              
            document.getElementById('clearAll').addEventListener('click', clearAll);  
            document.getElementById('clearMandala').addEventListener('click', clearMandala);  
            document.getElementById('clearParticles').addEventListener('click', clearParticles);  
            document.getElementById('previewExport').addEventListener('click', previewExport);  
            document.getElementById('freeDownload').addEventListener('click', freeDownload);  
              
            window.addEventListener('resize', onWindowResize);  
        }  
          
        function setMode(mode) {  
            currentMode = mode;  
              
            document.querySelectorAll('.mode-buttons button, #combinedMode').forEach(btn => {  
                btn.classList.remove('active');  
            });  
              
            const mandalaControls = document.getElementById('mandalaControls');  
            const particleControls = document.getElementById('particleControls');  
              
            switch(mode) {  
                case 'mandala':  
                    document.getElementById('mandalaMode').classList.add('active');  
                    mandalaControls.style.display = 'block';  
                    particleControls.style.display = 'none';  
                    break;  
                case 'particle':  
                    document.getElementById('particleMode').classList.add('active');  
                    mandalaControls.style.display = 'none';  
                    particleControls.style.display = 'block';  
                    break;  
                case 'combined':  
                    document.getElementById('combinedMode').classList.add('active');  
                    mandalaControls.style.display = 'block';  
                    particleControls.style.display = 'block';  
                    break;  
            }  
        }  
          
        function handleTouch(e) {  
            e.preventDefault();  
            const touch = e.touches[0];  
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' :   
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {  
                clientX: touch.clientX,  
                clientY: touch.clientY  
            });  
            mandalaCanvas.dispatchEvent(mouseEvent);  
        }  
          
        function getMousePos(e) {  
            const rect = mandalaCanvas.getBoundingClientRect();  
            return {  
                x: (e.clientX - rect.left) * (mandalaCanvas.width / rect.width),  
                y: (e.clientY - rect.top) * (mandalaCanvas.height / rect.height)  
            };  
        }  
          
        function startDrawing(e) {  
            if (e.target.closest('.controls')) return;  
              
            isDrawing = true;  
            const pos = getMousePos(e);  
            lastX = pos.x;  
            lastY = pos.y;  
            lastAudioX = pos.x;  
            lastAudioY = pos.y;  
              
            // Play initial note  
            playNote(pos.x, pos.y);  
        }  
          
        function draw(e) {  
            if (!isDrawing) return;  
              
            const pos = getMousePos(e);  
              
            if (currentMode === 'mandala' || currentMode === 'combined') {  
                drawMandala(pos.x, pos.y);  
            }  
              
            if (currentMode === 'particle' || currentMode === 'combined') {  
                emitParticles(pos.x, pos.y);  
            }  
              
            // CONTINUOUS AUDIO - THIS IS THE FIX  
            const now = Date.now();  
            if (now - audioLastTrigger > 100) {  
                playNote(pos.x, pos.y);  
                audioLastTrigger = now;  
            }  
              
            lastAudioX = lastX;  
            lastAudioY = lastY;  
            lastX = pos.x;  
            lastY = pos.y;  
        }  
          
        function stopDrawing() {  
            isDrawing = false;  
        }  
          
        // WORKING AUDIO FUNCTION FROM V2  
        function playNote(x, y) {  
            if (!audioEnabled || !synth) return;  
              
            const note = getPositionNote(x, y);  
            const velocity = getVelocity(x, y);  
              
            synth.triggerAttackRelease(note, '8n', undefined, velocity);  
              
            document.getElementById('lastNote').textContent = note;  
        }  
          
        function getPositionNote(x, y) {  
            const normalizedX = Math.max(0, Math.min(1, x / window.innerWidth));  
            const normalizedY = Math.max(0, Math.min(1, y / window.innerHeight));  
              
            const minorScaleNotes = [  
                'A2', 'B2', 'C3', 'D3', 'E3', 'F3', 'G3',  
                'A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4',  
                'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5',  
                'A5', 'B5', 'C6', 'D6', 'E6'  
            ];  
              
            const baseIndex = Math.floor(normalizedX * 16);  
            const yVariation = Math.floor(normalizedY * 4);  
            const finalIndex = Math.min(baseIndex + yVariation * 4, minorScaleNotes.length - 1);  
              
            return minorScaleNotes[finalIndex] || 'A3';  
        }  
          
        function getVelocity(x, y) {  
            const deltaX = Math.abs(x - lastAudioX);  
            const deltaY = Math.abs(y - lastAudioY);  
            const speed = Math.sqrt(deltaX * deltaX + deltaY * deltaY);  
              
            return Math.min(1.0, 0.3 + (speed / 50) * 0.7);  
        }  
          
        function drawMandala(x, y) {  
            mandalaCtx.strokeStyle = mandalaColor;  
            mandalaCtx.lineWidth = brushSize;  
            mandalaCtx.lineCap = 'round';  
            mandalaCtx.lineJoin = 'round';  
              
            if (symmetryEnabled) {  
                const centerX = mandalaCanvas.width / 2;  
                const centerY = mandalaCanvas.height / 2;  
                const angleStep = (2 * Math.PI) / symmetryPoints;  
                  
                for (let i = 0; i < symmetryPoints; i++) {  
                    const angle = i * angleStep;  
                      
                    const dx = x - centerX;  
                    const dy = y - centerY;  
                    const rotatedX = centerX + dx * Math.cos(angle) - dy * Math.sin(angle);  
                    const rotatedY = centerY + dx * Math.sin(angle) + dy * Math.cos(angle);  
                      
                    const lastDx = lastX - centerX;  
                    const lastDy = lastY - centerY;  
                    const rotatedLastX = centerX + lastDx * Math.cos(angle) - lastDy * Math.sin(angle);  
                    const rotatedLastY = centerY + lastDx * Math.sin(angle) + lastDy * Math.cos(angle);  
                      
                    mandalaCtx.beginPath();  
                    mandalaCtx.moveTo(rotatedLastX, rotatedLastY);  
                    mandalaCtx.lineTo(rotatedX, rotatedY);  
                    mandalaCtx.stroke();  
                }  
            } else {  
                mandalaCtx.beginPath();  
                mandalaCtx.moveTo(lastX, lastY);  
                mandalaCtx.lineTo(x, y);  
                mandalaCtx.stroke();  
            }  
        }  
          
        function emitParticles(x, y) {  
            const count = Math.floor(particleParams.emissionRate / 10);  
              
            for (let i = 0; i < count; i++) {  
                const worldX = (x / window.innerWidth) * 20 - 10;  
                const worldY = -(y / window.innerHeight) * 20 + 10;  
                const worldZ = (Math.random() - 0.5) * 2;  
                  
                const particle = {  
                    position: new THREE.Vector3(worldX, worldY, worldZ),  
                    velocity: new THREE.Vector3(  
                        (Math.random() - 0.5) * 2,  
                        Math.random() * 2,  
                        (Math.random() - 0.5) * 2  
                    ),  
                    life: 5.0,  
                    maxLife: 5.0,  
                    size: particleParams.size + Math.random() * 2  
                };  
                  
                particleParams.particles.push(particle);  
            }  
        }  
          
        function animate() {  
            requestAnimationFrame(animate);  
            updateParticles();  
            updateParticleGeometry();  
            renderer.render(scene, camera);  
        }  
          
        function updateParticles() {  
            const deltaTime = 0.016;  
              
            for (let i = particleParams.particles.length - 1; i >= 0; i--) {  
                const particle = particleParams.particles[i];  
                  
                particle.velocity.y += particleParams.gravity * deltaTime;  
                particle.velocity.x += particleParams.wind * deltaTime * 0.1;  
                particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime));  
                particle.life -= deltaTime;  
                  
                if (particle.life <= 0) {  
                    particleParams.particles.splice(i, 1);  
                }  
            }  
              
            while (particleParams.particles.length > 1000) {  
                particleParams.particles.shift();  
            }  
        }  
          
        function updateParticleGeometry() {  
            const positions = particleSystem.geometry.attributes.position.array;  
            const colors = particleSystem.geometry.attributes.color.array;  
            const sizes = particleSystem.geometry.attributes.size.array;  
              
            for (let i = 0; i < 1000; i++) {  
                if (i < particleParams.particles.length) {  
                    const particle = particleParams.particles[i];  
                    const lifeRatio = particle.life / particle.maxLife;  
                      
                    positions[i * 3] = particle.position.x;  
                    positions[i * 3 + 1] = particle.position.y;  
                    positions[i * 3 + 2] = particle.position.z;  
                      
                    const color = particleParams.startColor.clone().lerp(particleParams.endColor, 1 - lifeRatio);  
                    colors[i * 3] = color.r;  
                    colors[i * 3 + 1] = color.g;  
                    colors[i * 3 + 2] = color.b;  
                      
                    sizes[i] = particle.size * lifeRatio;  
                } else {  
                    positions[i * 3] = 0;  
                    positions[i * 3 + 1] = 0;  
                    positions[i * 3 + 2] = 0;  
                    sizes[i] = 0;  
                }  
            }  
              
            particleSystem.geometry.attributes.position.needsUpdate = true;  
            particleSystem.geometry.attributes.color.needsUpdate = true;  
            particleSystem.geometry.attributes.size.needsUpdate = true;  
        }  
          
        function clearAll() {  
            clearMandala();  
            clearParticles();  
        }  
          
        function clearMandala() {  
            mandalaCtx.clearRect(0, 0, mandalaCanvas.width, mandalaCanvas.height);  
        }  
          
        function clearParticles() {  
            particleParams.particles = [];  
        }  
          
        function previewExport() {  
            alert('Preview: Combined image of mandala + particles');  
        }  
          
        function freeDownload() {  
            const link = document.createElement('a');  
            link.download = 'musical-art-' + Date.now() + '.png';  
            link.href = mandalaCanvas.toDataURL();  
            link.click();  
        }  
          
        function onWindowResize() {  
            mandalaCanvas.width = window.innerWidth;  
            mandalaCanvas.height = window.innerHeight;  
              
            camera.aspect = window.innerWidth / window.innerHeight;  
            camera.updateProjectionMatrix();  
            renderer.setSize(window.innerWidth, window.innerHeight);  
        }  
        function toggleControls() {
    const controls = document.getElementById('controls');
    controlsVisible = !controlsVisible;

    if (controlsVisible) {
        controls.classList.remove('hidden');
    } else {
        controls.classList.add('hidden');
    }
}
          
        window.addEventListener('load', init);  
    </script>  
</body>  
</html>