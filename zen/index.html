<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUAX: Zen Particle Garden</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* --- CSS STYLES --- */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Share Tech Mono', monospace; /* Fallback for VCR OSD */
            background: #000;
            color: rgb(0, 242, 255);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #container { position: relative; width: 100%; height: 100%; }
        canvas { display: block; }

        /* UI CONTROLS */
        #controls {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(10, 10, 10, 0.85);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 242, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.1);
            max-height: 80vh;
            overflow-y: auto;
            width: 300px;
            z-index: 1000;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.27), opacity 0.4s ease;
        }

        #controls.hidden {
            transform: translateX(350px);
            opacity: 0;
            pointer-events: none;
        }

        /* SCROLLBAR Styling */
        #controls::-webkit-scrollbar { width: 6px; }
        #controls::-webkit-scrollbar-track { background: #1a1a1a; }
        #controls::-webkit-scrollbar-thumb { background: #00f2ff; border-radius: 3px; }

        .control-group { margin-bottom: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 10px; }
        .control-group:last-child { border-bottom: none; }

        .control-group-header {
            cursor: pointer;
            padding: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ff00cc;
        }
        .control-group-header:hover { color: #fff; text-shadow: 0 0 8px #ff00cc; }
        
        .control-group h3 { font-size: 16px; letter-spacing: 1px; text-transform: uppercase; }
        .control-group-body { display: block; padding-top: 5px; }
        .control-group-body.collapsed { display: none; }

        .control-item { margin-bottom: 12px; }
        label { display: block; font-size: 12px; color: #aaa; margin-bottom: 4px; }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            appearance: none;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #00f2ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px #00f2ff;
        }

        select {
            width: 100%;
            background: #111;
            color: #00f2ff;
            border: 1px solid #333;
            padding: 5px;
            font-family: 'Share Tech Mono', monospace;
        }

        .value-display { text-align: right; font-size: 12px; color: #fff; margin-top: -15px; pointer-events: none; }

        /* BUTTONS */
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            background: rgba(0, 242, 255, 0.1);
            border: 1px solid rgba(0, 242, 255, 0.5);
            color: #00f2ff;
            font-family: 'Share Tech Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        button:hover { background: rgba(0, 242, 255, 0.3); box-shadow: 0 0 15px rgba(0, 242, 255, 0.4); }

        .toggle-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            width: auto;
            z-index: 1001;
            background: #000;
            border: 1px solid #ff00cc;
            color: #ff00cc;
        }

        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #555;
            font-size: 10px;
            pointer-events: none;
        }

        #overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
        }
        
        #startButton { width: 200px; font-size: 18px; letter-spacing: 2px; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 style="color:white; margin-bottom:20px; text-shadow: 0 0 10px #00f2ff;">FUAX SYSTEM</h1>
        <button id="startButton">INITIALIZE</button>
    </div>

    <div id="container">
        <button class="toggle-controls" onclick="toggleUI()">TOGGLE UI</button>

        <div id="controls">
            <div class="control-group">
                <div class="control-group-header"><h3>Mode</h3><span>▼</span></div>
                <div class="control-group-body">
                    <div class="control-item">
                        <select id="interactionMode">
                            <option value="zen">ZEN (Gravity)</option>
                            <option value="fluid">FLUID (Ink)</option>
                            <option value="constrained">WEB (Swarm)</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-group-header"><h3>Emission</h3><span>▼</span></div>
                <div class="control-group-body">
                    <div class="control-item">
                        <label>Active Particles</label>
                        <input type="range" id="particleCount" min="1000" max="30000" value="30000" step="1000">
                        <div class="value-display" id="particleCountValue">30000</div>
                    </div>
                    <div class="control-item">
                        <label>Burst Size (Click)</label>
                        <input type="range" id="burstSize" min="10" max="500" value="100" step="10">
                        <div class="value-display" id="burstSizeValue">100</div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-group-header"><h3>Visuals</h3><span>▼</span></div>
                <div class="control-group-body">
                    <div class="control-item">
                        <label>Start Color</label>
                        <input type="color" id="startColor" value="#ffffff">
                    </div>
                    <div class="control-item">
                        <label>End Color</label>
                        <input type="color" id="endColor" value="#ff00cc">
                    </div>
                    <div class="control-item">
                        <label>Size</label>
                        <input type="range" id="particleSize" min="0.1" max="5" value="0.8" step="0.1">
                        <div class="value-display" id="particleSizeValue">0.8</div>
                    </div>
                    <div class="control-item">
                        <label>Opacity</label>
                        <input type="range" id="opacity" min="0.1" max="1" value="0.6" step="0.1">
                        <div class="value-display" id="opacityValue">0.6</div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-group-header"><h3>Physics</h3><span>▼</span></div>
                <div class="control-group-body">
                    <div class="control-item">
                        <label>Gravity/Force</label>
                        <input type="range" id="gravity" min="-2" max="2" value="-0.3" step="0.1">
                        <div class="value-display" id="gravityValue">-0.3</div>
                    </div>
                    <div class="control-item">
                        <label>Turbulence</label>
                        <input type="range" id="turbulence" min="0" max="3" value="0.5" step="0.1">
                        <div class="value-display" id="turbulenceValue">0.5</div>
                    </div>
                </div>
            </div>
            
            <button onclick="resetDefaults()">SYSTEM RESET</button>
        </div>

        <div id="stats">
            <span id="fps">60</span> FPS | <span id="activeCount">0</span> PARTICLES
        </div>
    </div>

    <script>
        // --- ARCHITECTURE ---
        // 1. Config & State
        // 2. Audio System (Tone.js)
        // 3. Visual System (Three.js)
        // 4. Interaction

        const CONSTANTS = {
            MAX_PARTICLES: 35000, // Hard cap to prevent crashes
        };

        const state = {
            count: 30000,
            mode: 'zen', // zen, fluid, constrained
            gravity: -0.3,
            turbulence: 0.5,
            size: 0.8,
            opacity: 0.6,
            startColor: new THREE.Color('#ffffff'),
            endColor: new THREE.Color('#ff00cc'),
            burstSize: 100,
            cursor: new THREE.Vector3(0,0,0)
        };

        // --- AUDIO SYSTEM ---
        const AudioSys = {
            ready: false,
            synth: null,
            init: async () => {
                await Tone.start();
                
                // Cyberpunk Synth Setup
                const reverb = new Tone.Reverb({ decay: 4, preDelay: 0.2 }).toDestination();
                const delay = new Tone.FeedbackDelay("8n", 0.5).connect(reverb);
                
                AudioSys.synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1 }
                }).connect(delay);
                
                AudioSys.synth.volume.value = -10;
                AudioSys.ready = true;
            },
            trigger: () => {
                if(!AudioSys.ready) return;
                const notes = ["C4", "E4", "G4", "A4", "C5", "D5"];
                const note = notes[Math.floor(Math.random() * notes.length)];
                AudioSys.synth.triggerAttackRelease(note, "16n");
            }
        };

        // --- VISUAL SYSTEM ---
        let scene, camera, renderer;
        let particleSystem;
        let clock = new THREE.Clock();

        class ParticleEngine {
            constructor() {
                this.geometry = new THREE.BufferGeometry();
                
                // Pre-allocate ALL memory to avoid garbage collection stutter
                this.positions = new Float32Array(CONSTANTS.MAX_PARTICLES * 3);
                this.colors = new Float32Array(CONSTANTS.MAX_PARTICLES * 3);
                this.sizes = new Float32Array(CONSTANTS.MAX_PARTICLES);
                this.alphas = new Float32Array(CONSTANTS.MAX_PARTICLES);
                
                // Physics Data (CPU side)
                this.velocities = [];
                this.lifes = [];
                
                for(let i=0; i<CONSTANTS.MAX_PARTICLES; i++) {
                    this.velocities.push({x:0, y:0, z:0});
                    this.lifes.push(0);
                    // Hide initially
                    this.positions[i*3] = 99999;
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.alphas, 1));

                // Shader Material for Performance
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        pointTexture: { value: this.createTexture() }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute float alpha;
                        varying float vAlpha;
                        varying vec3 vColor;
                        void main() {
                            vAlpha = alpha;
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D pointTexture;
                        varying float vAlpha;
                        varying vec3 vColor;
                        void main() {
                            if (vAlpha < 0.01) discard;
                            gl_FragColor = vec4(vColor, vAlpha);
                            gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true,
                    vertexColors: true
                });

                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
                
                this.activeCount = 0; // Track actually alive particles
            }

            createTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
                return new THREE.CanvasTexture(canvas);
            }

            emit(count, origin) {
                // Find dead particles and recycle them
                let emitted = 0;
                for(let i=0; i<state.count; i++) {
                    if(emitted >= count) break;
                    
                    if(this.lifes[i] <= 0) {
                        // Reset Particle
                        this.positions[i*3] = origin.x;
                        this.positions[i*3+1] = origin.y;
                        this.positions[i*3+2] = origin.z;
                        
                        // Initial Velocity spread
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const speed = 1 + Math.random() * 2;
                        
                        this.velocities[i].x = Math.sin(phi) * Math.cos(theta) * speed;
                        this.velocities[i].y = Math.sin(phi) * Math.sin(theta) * speed;
                        this.velocities[i].z = Math.cos(phi) * speed;

                        this.lifes[i] = 1.0; // Life starts at 1
                        emitted++;
                    }
                }
            }

            update(dt) {
                const positions = this.geometry.attributes.position.array;
                const alphas = this.geometry.attributes.alpha.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;

                let active = 0;
                const time = Date.now() * 0.001;

                for(let i=0; i<state.count; i++) {
                    if(this.lifes[i] > 0) {
                        active++;
                        
                        // --- PHYSICS KERNEL ---
                        const vx = this.velocities[i].x;
                        const vy = this.velocities[i].y;
                        const vz = this.velocities[i].z;

                        if (state.mode === 'fluid') {
                            // Fluid: High Drag, Swirly
                            this.velocities[i].x *= 0.92;
                            this.velocities[i].y *= 0.92;
                            this.velocities[i].z *= 0.92;
                            this.velocities[i].y += 0.02; // Slow rise
                            
                            // Noise-ish curl
                            this.velocities[i].x += Math.sin(positions[i*3+1] * 0.5 + time) * state.turbulence * dt;
                            
                        } else if (state.mode === 'constrained') {
                            // Web: Attract to cursor
                            const dx = state.cursor.x - positions[i*3];
                            const dy = state.cursor.y - positions[i*3+1];
                            const dz = state.cursor.z - positions[i*3+2];
                            
                            this.velocities[i].x += dx * 2 * dt;
                            this.velocities[i].y += dy * 2 * dt;
                            this.velocities[i].z += dz * 2 * dt;
                            
                            this.velocities[i].x *= 0.90; // Dampen
                            this.velocities[i].y *= 0.90;
                            this.velocities[i].z *= 0.90;

                        } else {
                            // Zen: Standard Gravity
                            this.velocities[i].y += state.gravity * dt;
                            this.velocities[i].x += Math.sin(time + i) * state.turbulence * dt;
                        }

                        // Apply Velocity
                        positions[i*3] += this.velocities[i].x * dt;
                        positions[i*3+1] += this.velocities[i].y * dt;
                        positions[i*3+2] += this.velocities[i].z * dt;

                        // Life Decay
                        const decayRate = state.mode === 'zen' ? 0.3 : 0.8;
                        this.lifes[i] -= dt * decayRate;

                        // Rendering Updates
                        alphas[i] = this.lifes[i] * state.opacity;
                        sizes[i] = state.size * this.lifes[i];
                        
                        // Color Interpolation
                        const c = state.startColor.clone().lerp(state.endColor, 1 - this.lifes[i]);
                        colors[i*3] = c.r;
                        colors[i*3+1] = c.g;
                        colors[i*3+2] = c.b;

                    } else {
                        // Move to hidden area
                        alphas[i] = 0;
                        positions[i*3] = 99999;
                    }
                }

                // If Zen Mode, auto-emit to maintain flow
                if (state.mode === 'zen' && active < state.count) {
                    this.emit(20, new THREE.Vector3(0, -5, 0));
                }

                // Update Buffers
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.alpha.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
                
                document.getElementById('activeCount').innerText = active;
            }
        }

        // --- INIT & LOOP ---
        function init() {
            scene = new THREE.Scene();
            // Gradient Background Hack
            const canvas = document.createElement('canvas');
            canvas.width=2; canvas.height=256;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0,0,0,256);
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#1a051d');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,2,256);
            scene.background = new THREE.CanvasTexture(canvas);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            particleSystem = new ParticleEngine();

            // Raycaster for interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, target);
                state.cursor.copy(target);

                if (state.mode === 'fluid') {
                    particleSystem.emit(5, target);
                }
            });

            window.addEventListener('mousedown', (e) => {
                if(e.target.tagName === 'CANVAS') {
                    particleSystem.emit(state.burstSize, state.cursor);
                    AudioSys.trigger();
                }
            });

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent huge jumps
            particleSystem.update(dt);
            renderer.render(scene, camera);
            
            document.getElementById('fps').innerText = Math.round(1/dt);
        }

        // --- UI WIRING ---
        document.getElementById('startButton').addEventListener('click', () => {
            AudioSys.init();
            document.getElementById('overlay').style.display = 'none';
            init();
        });

        // UI Event Listeners
        const inputs = ['interactionMode', 'particleCount', 'burstSize', 'gravity', 'turbulence', 'particleSize', 'opacity', 'startColor', 'endColor'];
        
        inputs.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', (e) => {
                const val = e.target.value;
                if (id === 'startColor' || id === 'endColor') {
                    state[id] = new THREE.Color(val);
                } else if (id === 'interactionMode') {
                    state.mode = val;
                    // Auto-adjust physics for modes
                    if (val === 'fluid') { state.gravity = 0; state.turbulence = 2; }
                    if (val === 'constrained') { state.gravity = 0; state.turbulence = 0.5; }
                    if (val === 'zen') { state.gravity = -0.3; }
                } else {
                    state[id] = parseFloat(val);
                    const disp = document.getElementById(id+'Value');
                    if(disp) disp.innerText = val;
                }
            });
        });

        // Accordion Logic
        document.querySelectorAll('.control-group-header').forEach(header => {
            header.addEventListener('click', () => {
                header.nextElementSibling.classList.toggle('collapsed');
            });
        });

        function toggleUI() {
            document.getElementById('controls').classList.toggle('hidden');
        }

        function resetDefaults() {
            // Just reload to clear state, easiest for user
            location.reload();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
